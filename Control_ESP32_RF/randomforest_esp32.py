# -*- coding: utf-8 -*-
"""RandomForest_ESP32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TaIiMXHg7wuIP13Lcu2kMngkYvkSL9mC

Solenoid位置計測
Tonとv0,v1からPosとTempをRandom Forestで推測する (from ChatGPT)
ESP32用コードの生成のためのモデル学習
"""

import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import joblib

# データの読み込み
data = pd.read_excel('test.xlsx')

# 特徴量とターゲットの分割
X = data[['Ton[ms]', 'v0', 'v1']]
y_pos = data['Pos[mm]']
y_temp = data['Temp[degC]']

# 訓練データとテストデータに分割
X_train, X_test, y_pos_train, y_pos_test, y_temp_train, y_temp_test = train_test_split(X, y_pos, y_temp, test_size=0.2, random_state=42)

# ランダムフォレストモデルの訓練
rf_pos = RandomForestRegressor(n_estimators=100, random_state=42)
rf_pos.fit(X_train, y_pos_train)

rf_temp = RandomForestRegressor(n_estimators=100, random_state=42)
rf_temp.fit(X_train, y_temp_train)

# モデルの評価
pos_predictions = rf_pos.predict(X_test)
temp_predictions = rf_temp.predict(X_test)

print("Pos Mean Squared Error:", mean_squared_error(y_pos_test, pos_predictions))
print("Temp Mean Squared Error:", mean_squared_error(y_temp_test, temp_predictions))

# モデルの保存
joblib.dump(rf_pos, 'rf_pos_model.pkl')
joblib.dump(rf_temp, 'rf_temp_model.pkl')

"""モデルからESP32用コードを生成"""

import joblib
import numpy as np

# モデルの読み込み
rf_pos = joblib.load('rf_pos_model.pkl')
rf_temp = joblib.load('rf_temp_model.pkl')

# ランダムフォレストモデルのパラメータ抽出
def extract_rf_parameters(model):
    estimators = model.estimators_
    n_estimators = len(estimators)
    trees = []
    for estimator in estimators:
        tree = estimator.tree_
        nodes = []
        for i in range(tree.node_count):
            if tree.children_left[i] == tree.children_right[i]:
                nodes.append({
                    'left': -1,
                    'right': -1,
                    'threshold': -2,
                    'value': tree.value[i].tolist()
                })
            else:
                nodes.append({
                    'left': tree.children_left[i],
                    'right': tree.children_right[i],
                    'threshold': tree.threshold[i],
                    'feature': tree.feature[i]
                })
        trees.append(nodes)
    return trees

rf_pos_params = extract_rf_parameters(rf_pos)
rf_temp_params = extract_rf_parameters(rf_temp)

# ESP32用コードの生成
def generate_esp32_code(rf_params, model_name):
    Nmax = 0
    for i, tree in enumerate(rf_params):
      N = len(tree)
      if (N > Nmax):
        Nmax = N

    code = f"#include <stdio.h>\n\n"
    code += f"#define N_ESTIMATORS {len(rf_params)}\n\n"

    code += f"const int {model_name}_tree_nodes[{len(rf_params)}][{Nmax}][5] = {{\n"
    for i, tree in enumerate(rf_params):
#        code += f"const int {model_name}_tree_{i}_nodes[{len(tree)}][5] = {{\n"
        code += f"{{ // {i}\n"
        for node in tree:
            t = node.get('value', [0])[0]
            if (type(t) is int):
              code += f"    {{ {node['left']:.0f}, {node['right']:.0f}, {node['threshold']:.0f}, {node.get('feature', -1):.0f}, {t} }},\n"
            else:
              code += f"    {{ {node['left']:.0f}, {node['right']:.0f}, {node['threshold']:.0f}, {node.get('feature', -1):.0f}, {t[0]:.0f} }},\n"
        for j in range(Nmax - len(tree)):
            code += "    {0, 0, 0, 0, 0},\n"
#        code += "};\n\n"
        code += "},\n"

    code += "};\n"

    code += f"float predict_{model_name}(float *features) {{\n"
    code += f"    float predictions[N_ESTIMATORS];\n"
    code += f"    for (int i = 0; i < N_ESTIMATORS; i++) {{\n"
    code += f"        int node = 0;\n"
#    code += f"        while ({model_name}_tree_{{i}}_nodes[node][0] != -1) {{\n"
#    code += f"            if (features[{model_name}_tree_{{i}}_nodes[node][3]] <= {model_name}_tree_{{i}}_nodes[node][2]) {{\n"
#    code += f"                node = {model_name}_tree_{{i}}_nodes[node][0];\n"
#    code += f"            }} else {{\n"
#    code += f"                node = {model_name}_tree_{{i}}_nodes[node][1];\n"
#    code += f"            }}\n"
#    code += f"        }}\n"
#    code += f"        predictions[i] = {model_name}_tree_{{i}}_nodes[node][4];\n"

    code += f"        while ({model_name}_tree_nodes[i][node][0] != -1) {{\n"
    code += f"            if (features[{model_name}_tree_nodes[i][node][3]] <= {model_name}_tree_nodes[i][node][2]) {{\n"
    code += f"                node = {model_name}_tree_nodes[i][node][0];\n"
    code += f"            }} else {{\n"
    code += f"                node = {model_name}_tree_nodes[i][node][1];\n"
    code += f"            }}\n"
    code += f"        }}\n"
    code += f"        predictions[i] = {model_name}_tree_nodes[i][node][4];\n"

#    code += f"        int **p;\n"
#    code += f"        switch(i){{\n"
#    for k in range(100):
#      code += f"            case {k} : p = (int **)pos_tree_{k}_nodes; break;\n"
#    code += f"        }}\n"
#    code += f"        while (p[node][0] != -1) {{\n"
#    code += f"            if (features[p[node][3]] <= p[node][2]) {{\n"
#    code += f"                node = p[node][0];\n"
#    code += f"            }} else {{\n"
#    code += f"                node = p[node][1];\n"
#    code += f"            }}\n"
#    code += f"        }}\n"
#    code += f"        predictions[i] = p[node][4];\n"

    code += f"    }}\n"
    code += f"    float sum = 0.0;\n"
    code += f"    for (int i = 0; i < N_ESTIMATORS; i++) {{\n"
    code += f"        sum += predictions[i];\n"
    code += f"    }}\n"
    code += f"    return sum / N_ESTIMATORS;\n"
    code += f"}}\n"

    return code

esp32_code_pos = generate_esp32_code(rf_pos_params, 'pos')
esp32_code_temp = generate_esp32_code(rf_temp_params, 'temp')

# 生成されたコードを保存
with open('esp32_pos_prediction.c', 'w') as f:
    f.write(esp32_code_pos)

with open('esp32_temp_prediction.c', 'w') as f:
    f.write(esp32_code_temp)